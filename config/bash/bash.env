#! /usr/bin/env bash

# FIXME clean separation of personal/work settings

#
# Setup environment variables for bash, which shared by:
#
# - bash
# - provision scripts
#
# FIXME
# - revist why do I want to use bash.env for provisioning
# - also, think I was not meant to replace before/after with bash.env
#   - instead, extract patterns from before/after to appropriate place, e.g. addons
#   - may also want to provide warnings for those script on performance

#
# ideally we need some storage place that can persist data across reinstall
#

export __sandbox_path="/sandbox/$USER"
export __linuxbrew_root='/home/linuxbrew'

if [[ ! -d "$__linuxbrew_root" ]]; then
    sudo mkdir -p "$__linuxbrew_root"
fi

declare -A prefixes
declare -A executables

prefixes[conda]="$__sandbox_path/.conda"
prefixes[nvm]="$__sandbox_path/.nvm"
prefixes[linuxbrew]="$__linuxbrew_root/.linuxbrew"

executables[conda]="$__sandbox_path/.conda/bin"
executables[linuxbrew]="$__linuxbrew_root/.linuxbrew/bin:$__sandbox_path/.linuxbrew/sbin"

for name in "${!prefixes[@]}"; do
    prefix="${prefixes[$name]}"
    declare "__prefix_$name=$prefix"
done

for name in "${!executables[@]}"; do
    executable="${executables[$name]}"
    PATH="$executable:$PATH"
done

#
# TODO
# - may just get rid of nvm since we are not changing the versions too frequently anyway
node_version=$(command ls -1r "$__prefix_nvm/versions/node" | head -1)

if [[ -n "$node_version" ]]; then
    PATH="${__prefix_nvm:?}/versions/node/$node_version/bin:$PATH"
fi

# export MANPAGER='nvim -c "set ft=man" -'
export MANPAGER="sh -c 'col -bx | bat -l man -p'"

###############################
# Legacy stuff below
# may want to move to addons
###############################

# conda envs
export __conda_env_root="${prefixes[conda]}/envs"

#
# copied from bash/before
#

# FIXME workaround weird warnings prevent gsettings to be set
export GIO_EXTRA_MODULES=/usr/lib/x86_64-linux-gnu/gio/modules/

# FIXME this should really be fixed by ask admin to run locale-gen en_US.utf-8
export LANG="en_US.utf-8"

# FIXME temporary workaround for brew openssl with self-signed certificates
export HOMEBREW_FORCE_BREWED_CURL=1

# XXX Python 2.0 dies, long live Python 2.0
export PYTHONWARNINGS="ignore"

# XXX the lighting is pretty consistent in the office
export LUMINANCE_OVERRIDE="normal"

export EDITOR='vim'

#
# copied from bash/after
#

# shellcheck disable=SC1090 # we know where the source from
#
# Things need to be set up after eval the bashrc
#

#  ______  _____   ____    _____
# /\__  _\/\  __`\/\  _`\ /\  __`\
# \/_/\ \/\ \ \/\ \ \ \/\ \ \ \/\ \
#    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
#     \ \ \ \ \ \_\ \ \ \_\ \ \ \_\ \
#      \ \_\ \ \_____\ \____/\ \_____\
#       \/_/  \/_____/\/___/  \/_____/
#
# extract functions to add-ons, so before after should only be setting box
# specific stuff not functional craps
#

# PATH
#
export DEV_HOME="/sandbox/$USER"
export PATH="$DEV_HOME/repos/My/snippets/bin:$PATH"

#
# conda
#
export PATH="$DEV_HOME/.conda/bin:$PATH"
# this overwrites the default behaviour which includes redundant paths, e.g. $HOME/.conda/envs

#
# Linuxbrew
#
export HOMEBREW_GITHUB_API_TOKEN=7a4f5e70778d46fe64dae7bf52a6d0bccdcac379
export BREW_HOME="$DEV_HOME/.linuxbrew/"

# default values from https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html

XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}
export HOMEBREW_PREFIX="$DEV_HOME/.linuxbrew/"
export HOMEBREW_CACHE="$XDG_CACHE_HOME/Homebrew"
export HOMEBREW_LOGS="$XDG_CACHE_HOME/Homebrew/Logs"

# export MANPATH="$HOMEBREW_PREFIX/share/man:$MANPATH"
XDG_DATA_DIRS=${XDG_DATA_DIRS:- /usr/local/share/:/usr/share/}
export XDG_DATA_DIRS="$HOMEBREW_PREFIX/share:$XDG_DATA_DIRS"

if [[ -d $HOMEBREW_PREFIX/etc/bash_completion.d/ ]]; then
    for cmp_file in "$DEV_HOME"/.linuxbrew/etc/bash_completion.d/*; do
        source "$cmp_file"
    done
fi

#
# FIXME workaround to mitigate some conflict caused by brew commands precede system ones
#
# Rust related settings
export WINIT_HIDPI_FACTOR=1.0 # for now this only affects Alacritty

# miscellaneous binaries
export PATH="$DEV_HOME/bin:$PATH"

# FIXME why?
alias ssh='TERM=xterm-256color ssh'

# Make rdesktop great again!
# TODO may need to change domain after move
# magic number is for the best experience, see
# rdesktop -x 0x8F mywinserver   # equals the modem default + font smoothing
# rdesktop -x 0x81 mywinserver   # equals the broadband default + font smoothing
# rdesktop -x 0x80 mywinserver   # equals the LAN default + font smoothing
rdp() {
    dimension="$(xrandr | grep -oE 'primary [0-9x]{7,9}' | cut -d ' ' -f2)"
    width=$(($(echo "$dimension" | cut -d 'x' -f 1) * 9 / 10))
    height=$(($(echo "$dimension" | cut -d 'x' -f 2) * 9 / 10))
    echo "staring RPD in ${width}x${height}..."
    nohup rdesktop -d AKUNACHINA -g "${width}x${height}" -x 0x80 -a 32 -r sound=local "${1-sha-dev-vw101}" &
}

gr() {
    cd $(git rev-parse --show-toplevel || pwd)
}

# go to env at your fingertips
ge()
{
    if [[ -n "$__conda_env_root" ]]; then
        paths=$(find "$__conda_env_root" -maxdepth 1 -mindepth 1 -name "[!.]*")
    else
        paths=$(conda info --envs | awk '{ print $NF }' | grep '^/')
    fi

    path=$(fzf --height=50% --reverse <<<"$paths" | xargs -r echo "$@")

    [[ -d "$path" ]] && cd "$path"/lib/python*/site-packages || echo 'path not found!'
}

#
# Helper functions to make dev life easier
#

__log_s() {
    >&2 echo -e "\\e[32m$*\\e[0m"
}

__log_i() {
    >&2 echo -e "\\e[36m$*\\e[0m"
}

__log_w() {
    >&2 echo -e "\\e[33m$*\\e[0m"
}

__log_e() {
    >&2 echo -e "\\e[1;31m$*\\e[0m"
}

__conda_envs()
{
    local env_names

    if [[ ! -d "$__conda_env_root" ]]; then
        __log_w "\n\$__conda_env_root is not set, using conda info --base instead."
        __log_w "Please consider set \$__conda_env_root for faster access."
        __conda_env_root="$(conda info --base)/envs"
    fi

    env_names=$(find "$__conda_env_root" -maxdepth 1 -mindepth 1 -type d -exec basename {} \;)
    echo "$env_names"
}

# smart way to activate/deactivate conda environments
# TODO
# - [ ] it's actually quicker to do activate/deactivate myself
e()
{
    local env_name
    local current_py_env

  # deactivate current python venv if there is any
  current_py_env=$(grep -oP '\/.*conda.*/envs/(\K\w+)' <<< "$PATH")
  if [[ -n "$current_py_env" ]]; then
      echo "deactivating \"$current_py_env\" ..."
      source deactivate
      return 0
  fi

  # use env name if passed one explicitly
  env_name=$1

  # otherwise guess the envname
  if [[ -z "$env_name" ]]; then
      env_name=$(__.conda.clever_prefix | xargs --no-run-if-empty basename)
      fi

      if [[ -z "$env_name" ]]; then
          echo "cannot find a conda environment for \"$(basename "$PWD")\"!"
          return 1
      fi

      if [[ "$env_name" == "$current_py_env" ]]; then
          return 0
      fi

      source activate "$env_name"
      success=$?

      pip_path="$(type -P pip)"
      py_version="$(python -V 2>&1 | grep -Po '(?<=Python )(.+)')"
      conda_build_str="py$(echo ${py_version//./} | cut -c 1-2)_"

      __conda_dep_install()
      {
          # some of the packages require binary extension which can easily break if you use pip
          >&2 echo "conda install in background"
          for pkg_name in ipdb; do
              spec=$(conda search --override-channels --channel conda-forge "$pkg_name" | awk -v search="$conda_build_str" '$0 ~ search { print $1"="$2"="$3 }' | tail -1)
              >&2 echo "should do: conda install --yes -n $env_name $spec"
              if ! conda install --yes -n "$env_name" "$spec"; then
                  notify-send -u critical "Failed to updated $pkg_name for $env_name!"
              fi
          done
          >&2 echo "finished conda install in background"
      }

  __pip_dep_install()
  {
      >&2 echo "pip install in background"
      if ! "$pip_path" install --upgrade \
          pip \
          black \
          bpython \
          mypy \
          pylint; then
                #   notify-send "Update pip dev packages for $env_name!"
                # else
                notify-send -u critical "Failed to pip update for $env_name!"
      fi

      >&2 echo "finished pip install in background"
  }

  # Py2 is dying and not compatible with some of the tools
  # if [[ $success -eq 0 && -x "$pip_path" && "$py_version" == 3* ]]; then
  #     (
  #     __conda_dep_install >/dev/null 2>&1 \
  #         && __pip_dep_install >/dev/null 2>&1 \
  #         &
  #     )
  # fi
}

__e_complete()
{
    if [[ "${#COMP_WORDS[@]}" != "2" ]]; then
        return
    fi

    mapfile -t COMPREPLY < <(grep -oE "^${COMP_WORDS[1]}[0-9a-z_-]+" < <(__conda_envs))
}

# complete -F __e_complete -o default -o bashdefault e
complete -F __e_complete e

# Start webapp server for given app
# FIXME broken
__web_server()
{
    local path
    path=$(readlink -f "$1")
    local loc=${2:-chi}
    local env=${3:-prd}
    local config
    local config_root="${DEV_CFG_ROOT:-?}/$loc"

    if [[ ! -d "$path" ]]; then
        echo "\$path: $path is not a directory!"
        return 1
    fi

    echo 'getting app name using setup.py...'
    app=$(jq --raw-output .name "$path/package.json")

  # conda info --envs
  # if ! source activate "$app"; then
  #   echo "failed to activate conda env for $app, please double check!"
  #   return 1
  # fi

  echo 'checking config file...'
  echo "loc: $loc"
  echo "env: $env"
  echo "searching $config_root/$app/config.json ..."
  echo "searching $config_root/$app.json ..."
  echo "searching /sandbox/cfg/$loc/webapp.json ..."
  if [ -f "$config_root/$app/config.json" ]; then
      config="$config_root/$app/config.json"
  elif  [ -f "$config_root/$app.json" ]; then
      config="$config_root/$app.json"
  elif [ -f "/sandbox/cfg/$loc/webapp.json" ]; then
      config="/sandbox/cfg/$loc/webapp.json"
  else
      echo "no config file available!"
      return 1
  fi

  echo "------------------------------------------------------------------------"
  echo "starting $app..."
  echo "CONFIG: $config"
  echo "LOCATION: $loc"
  echo "ENV: $env"
  echo "------------------------------------------------------------------------"
  jq . "$config"
  echo "------------------------------------------------------------------------"

  echo 'launching app....'
  echo "./launch.py $app --debug -c $config -e $env --dangerously-disable-authentication"
  # ./launch.py "$app" --debug -c "$config" -e "$env" --dangerously-disable-authentication
  ./launch.py "$app" -c "$config" -e "$env" --dangerously-disable-authentication
}

locations=(ch hk)
environments=(dev prd)

for l in "${locations[@]}"; do
    for e in "${environments[@]}"; do
        eval "${l}_${e}()
        {
            if [[ -z \"\$1\" ]]; then
                echo 'Please provide an app name!'
                return 1
            fi
            __web_server \$1 ${l} ${e};
        }"
done
done

__soldump()
{
    # soldump binary is an legacy solace Python script
    if ! hash __soldump_cli > /dev/null 2>&1; then
        >&2 echo "Cannot find soldump in path"
        return 1
    fi

    host=${1:?}
    user=${2:?}
    psw=${3:?}
    vpn=${4:?}
    cache=${5:?}
    topic="${6:-v2/instrumental_v2/cache/*}"

    2>/dev/null __soldump_cli \
        -d \
        -s "$host" \
        -v "$vpn" \
        -u "$user" \
        -p "$psw" \
        -c "$cache" \
        "$topic"
}

soldump_ch_dev()
{
    __soldump \
        ch1devsolace.akunacapital.local \
        svc_akuna_pdle_id \
        25Mku4xkznvosn \
        ch_kunlun_vpn \
        ch_kunlun_cache \
        "$1"
}

soldump_ch_prd()
{
    __soldump \
        offdevsolpri01.akunacapital.local \
        soldevapp \
        2yvno5kzz \
        prdcopy \
        prd_akuna_cache \
        "$1"
}

soldump_hk_dev()
{
    __soldump \
        shadevklun02.akunacapital.local \
        svc_akuna_pdle_id \
        25Mku4xkznvosn \
        hk_kunlun_staging_vpn \
        hk_kunlun_staging_cache \
        "$1"
}

soldump_hk_prd()
{
    __soldump \
        hkedevsol03.akunacapital.local \
        soldevapp \
        2yvno5kzz \
        hkprdcopy \
        prd_hk_akuna_cache \
        "$1"
}

tmux_pair()
{
    local me
    me=$(whoami | cut -d '.' -f 1)

    tmux -S "/tmp/$me" new-session -d -s "$me" -n work -c ~/workspace/webapp
    tmux -S "/tmp/$me" send-keys -t "$me:work" "chgrp $(id --group) /tmp/vincent" Enter
    tmux -S "/tmp/$me" attach -t "$me:work"
}

# overwrite the default command_not_found handler to mitigate with the multiple
# versions of Python issue brought by Linuxbrew and conda
command_not_found_handle ()
{
    printf "%s: command not found\n" "$1" 1>&2;
    return 127;
}

# better keyboard/mouse behavouir
# XXX this is likely to change on different box
# FIXME Maybe an adaptive way to do it?
if [[ -z "${SSH_CLIENT:-x}" ]] && [[ -z "${SSH_TTY:-x}" ]]; then
    export DISPLAY=:1
    xset r rate 250 25
    xset m 1 4
fi

lint_jenkins()
(
if [[ ! -f Jenkinsfile ]]; then
    >&2 echo "Can't find Jenkins file at $PWD!"
    return 1
fi

_lint_jenkins()
{
    clear
    # curl (REST API)
    # Assuming "anonymous read access" has been enabled on your Jenkins instance.
    JENKINS_URL=${1:-'localhost:8080'}
    # JENKINS_CRUMB is needed if your Jenkins master has CRSF protection enabled as it should
    JENKINS_CRUMB=$(curl -s -u vincent:1201 "$JENKINS_URL/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,\":\",//crumb)")
    result=$(curl -s -u vincent:1201 -X POST -H "$JENKINS_CRUMB" -F "jenkinsfile=<Jenkinsfile" "$JENKINS_URL/pipeline-model-converter/validate")

    if [[ $(wc -l <<< "$result") -eq 1 ]]; then
        echo -en "\e[00;38;5;2m"
    else
        echo -en "\e[00;38;5;3m"
    fi
    echo "$result"
    echo -en "\e[0m"
}

_lint_jenkins "$@"

while inotifywait -q -e close_write Jenkinsfile; do
    _lint_jenkins "$@"
done
)

cr()
{
    # FIXME
    # - copied from gg, can extract out as a common pattern

    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        >&2 echo 'Please call me in a git repository!'
        return 1
    fi

    if ! hash fzf 2>/dev/null; then
        >&2 echo 'fzf is missing, how can you miss that?'
        return 1
    fi

    branch_name=$(
    git branch --no-color -a |\
        sed -r 's/^\s+//g' |\
        fzf --height=50% --reverse
    )

    local local_branch_name
    local remote_branch_name

    local_branch_name="review_$(date +%s%N)"

    if [[ "$branch_name" == 'remotes'* ]]; then
        remote_branch_name=$(echo "$branch_name" | cut -d '/' -f 2-)
    else
        remote_branch_name="$branch_name"
    fi

    review_path="/tmp/code_review/${local_branch_name}"
    echo "Creating a review copy at: $review_path..."
    > /dev/null rm -rf "$review_path"
    > /dev/null mkdir -p "$review_path"
    > /dev/null git worktree add "$review_path" -b "$local_branch_name" --track "$remote_branch_name"
    echo "Switching to review copy..."
    cd "$review_path" || return 1
}

kube_proxy(){
    admin_user="$(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}')"

    if [[ -z $admin_user ]]; then
        >&2 echo 'no admin_user found, please double check!'
        return 1
    fi

    token=$(kubectl -n kube-system describe secret "$admin_user" | awk '$1=="token:"{print $2}')

    if [[ -z $token ]]; then
        >&2 echo "Failed to get token for user $admin_user, please double check!"
        return 1
    fi

    >&2 echo 'visit: http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/'
    >&2 echo "with token:"
    >&2 echo '------------------'
    >&2 echo "$token"
    >&2 echo '------------------'

    kubectl proxy &
}

s() {
    # handy ssh launcher
    ssh "$(awk '/Host / { print $2 }' ~/.ssh/config | sort | fzf --height 40% --reverse)"
}

r() {
    repo_root="/home/vincent.zhang/repos/"
    repo_name=$(\
        find "$repo_root" -maxdepth 3 -type d -name .git |\
        cut -d '/' -f 5- |\
        xargs dirname |\
        sort -i |\
        fzf --height 40% --reverse \
    )

    if [[ -z "$repo_name" ]]; then
        >&2 echo "Please select a repo!"
        return 1
    fi

    cd "$repo_root/$repo_name" && return 0 || return 1
}

v() {
    # TODO fetch users from the server periodically for tab completion, e.g.
    # ssh photon_chicago_dev "docker ps | grep -oP 'vscode_\K([a-z]+\.[a-z]+)' | sort -u"
    # and put into file for autocomplete
    username=${1:-vincent.zhang}

    if id "$username" > /dev/null 2>&1; then
        >&2 echo "Connecting to vscode_$username on ch1devptn01..."
        ssh photon_chicago_dev -t "docker exec -it -e COLUMNS=\"$(tput cols)\" -e LINES=\"$(tput lines)\" vscode_$username bash"
    else
        >&2 echo "User: \"$username\" not found, please double check!"
    fi
}

unset PYTHONASYNCIODEBUG

photon_image_build() {
    # TODO
    # - move out of bash.env
    # - intelligent auto completion
    version=${1:?}
    task_name=${2:-apac.hke.unwarranted.unwarranted.UnwarrantedTask}

    if ! project_root=$(git rev-parse --show-toplevel); then
        >&2 echo "Please run this function inside the trader_scripts repo!"
        return 1
    fi

    if [[ -z "$version" ]]; then
        latest_tag=$(git tag | grep "$image_name" | tail -1)
        latest_version=$(awk -F _ '{print $NF}' <<<"$latest_tag")
        next_version=$(awk -F. '/[0-9]+\./{$NF++;print}' OFS=. <<<"$latest_version")
        >&2 echo "latest_tag: $latest_tag"
        >&2 echo "latest_version: $latest_version"
        >&2 echo "next_version: $next_version"
        version=$next_version
    fi

    cat <<BASH
photon image build \
  -t $image_name \
  -v $version \
  -e /sandbox/vincent.zhang/.conda/envs/unwarranted/ \
  -g $project_root
BASH
}

viper_build() {
    set -e
    project_root=$(git rev-parse --show-toplevel)

    # --user jenkins:jenkins \
    docker run \
        -it \
        --user "$(id -u):$(id -g)" \
        --rm \
        --env conda_build=3.17.8 \
        --env env=dev \
        --env convert=false \
        --env pythons=3.6 \
        -v "$project_root":/home/jenkins/workspace \
        ch1infnex01.akunacapital.local:5543/dev/viper
}

conda_search() {
    keyword=${1:?}
    curl \
        --silent \
        http://swrepo.akunacapital.local/pyrepo/v3/repo/prod/linux-64/repodata.json.bz2 |\
        bzip2 -dc |\
        jq ".packages | keys_unsorted[] | select(startswith(\"$keyword\"))"
        # fzf --reverse --height=40%
}

docker_compose_ci() {
    docker-compose --file docker-compose.ci.yaml up --build --force-recreate --remove-orphans --renew-anon-volumes --exit-code-from test --abort-on-container-exit
}

docker_compose_run() {
    docker-compose --file docker-compose.yaml up --force-recreate --remove-orphans
}

# recreate a conda env
re() {
    env_name=${1:-$(basename "$PWD")}
    file_name=${2:-environment.yaml}

    if [[ ! -f "$file_name" ]]; then
        >&2 echo "env file: $file_name not found, please double check!"
    fi

    conda env remove --name "$env_name" && conda env create --name "$env_name" --file "$file_name"
}

export DEV_CFG_ROOT=/sandbox/vincent.zhang/repos/My/web_dev_cfg

# vim: set autoindent expandtab shiftwidth=4 tabstop=4 :
